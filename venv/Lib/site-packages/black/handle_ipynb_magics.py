# encoding: utf-8
# module black.handle_ipynb_magics
# from C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\site-packages\black\handle_ipynb_magics.cp311-win_amd64.pyd
# by generator 1.147
# no doc

# imports
import ast as ast # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\ast.py
import collections as collections # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\collections\__init__.py
import dataclasses as dataclasses # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\dataclasses.py
import secrets as secrets # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\secrets.py
import sys as sys # <module 'sys' (built-in)>
import ast as __ast


# functions

def Dict(*args, **kwargs): # real signature unknown
    """ A generic version of dict. """
    pass

def find_spec(name, package=None): # reliably restored by inspect
    """
    Return the spec for the specified module.
    
        First, sys.modules is checked to see if the module was already imported. If
        so, then sys.modules[name].__spec__ is returned. If that happens to be
        set to None, then ValueError is raised. If the module is not in
        sys.modules, then sys.meta_path is searched for a suitable spec with the
        value of 'path' given to the finders. None is returned if no spec could
        be found.
    
        If the name is for submodule (contains a dot), the parent module is
        automatically imported.
    
        The name and package arguments work the same as importlib.import_module().
        In other words, relative module names (with leading dots) work.
    """
    pass

def get_token(*args, **kwargs): # real signature unknown
    pass

def jupyter_dependencies_are_installed(*args, **kwargs): # real signature unknown
    pass

def List(*args, **kwargs): # real signature unknown
    """ A generic version of list. """
    pass

def lru_cache(maxsize=128, typed=False): # reliably restored by inspect
    """
    Least-recently-used cache decorator.
    
        If *maxsize* is set to None, the LRU features are disabled and the cache
        can grow without bound.
    
        If *typed* is True, arguments of different types will be cached separately.
        For example, f(3.0) and f(3) will be treated as distinct calls with
        distinct results.
    
        Arguments to the cached function must be hashable.
    
        View the cache statistics named tuple (hits, misses, maxsize, currsize)
        with f.cache_info().  Clear the cache and statistics with f.cache_clear().
        Access the underlying function with f.__wrapped__.
    
        See:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)
    """
    pass

def mask_cell(*args, **kwargs): # real signature unknown
    pass

def Optional(*args, **kwargs): # real signature unknown
    """ Optional[X] is equivalent to Union[X, None]. """
    pass

def out(message=None, nl=True, **styles): # reliably restored by inspect
    # no doc
    pass

def put_trailing_semicolon_back(*args, **kwargs): # real signature unknown
    pass

def remove_trailing_semicolon(*args, **kwargs): # real signature unknown
    pass

def replace_cell_magics(*args, **kwargs): # real signature unknown
    pass

def replace_magics(*args, **kwargs): # real signature unknown
    pass

def TOKEN_HEX(nbytes=None): # reliably restored by inspect
    """
    Return a random text string, in hexadecimal.
    
        The string has *nbytes* random bytes, each byte converted to two
        hex digits.  If *nbytes* is ``None`` or not supplied, a reasonable
        default is used.
    
        >>> token_hex(16)  #doctest:+SKIP
        'f9bf78b9a18ce6d46a0cd2b0b86df9da'
    """
    pass

def Tuple(*args, **kwargs): # real signature unknown
    """
    Deprecated alias to builtins.tuple.
    
        Tuple[X, Y] is the cross-product type of X and Y.
    
        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.
    
        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
    """
    pass

def TypeGuard(*args, **kwargs): # real signature unknown
    """
    Special typing construct for marking user-defined type guard functions.
    
        ``TypeGuard`` can be used to annotate the return type of a user-defined
        type guard function.  ``TypeGuard`` only accepts a single type argument.
        At runtime, functions marked this way should return a boolean.
    
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
        type checkers to determine a more precise type of an expression within a
        program's code flow.  Usually type narrowing is done by analyzing
        conditional code flow and applying the narrowing to a block of code.  The
        conditional expression here is sometimes referred to as a "type guard".
    
        Sometimes it would be convenient to use a user-defined boolean function
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its
        return type to alert static type checkers to this intention.
    
        Using  ``-> TypeGuard`` tells the static type checker that for a given
        function:
    
        1. The return value is a boolean.
        2. If the return value is ``True``, the type of its argument
           is the type inside ``TypeGuard``.
    
           For example::
    
               def is_str(val: Union[str, float]):
                   # "isinstance" type guard
                   if isinstance(val, str):
                       # Type of ``val`` is narrowed to ``str``
                       ...
                   else:
                       # Else, type of ``val`` is narrowed to ``float``.
                       ...
    
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
        form of ``TypeA`` (it can even be a wider form) and this may lead to
        type-unsafe results.  The main reason is to allow for things like
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not
        a subtype of the former, since ``List`` is invariant.  The responsibility of
        writing type-safe type guards is left to the user.
    
        ``TypeGuard`` also works with type variables.  For more information, see
        PEP 647 (User-Defined Type Guards).
    """
    pass

def unmask_cell(*args, **kwargs): # real signature unknown
    pass

def _get_str_args(*args, **kwargs): # real signature unknown
    pass

def _is_ipython_magic(*args, **kwargs): # real signature unknown
    pass

# classes

class CellMagic(object):
    # no doc
    def __delattr__(self, name): # reliably restored by inspect
        # no doc
        pass

    def __eq__(self, other): # reliably restored by inspect
        # no doc
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __hash__(self): # reliably restored by inspect
        # no doc
        pass

    def __init__(self, name, params, body): # reliably restored by inspect
        # no doc
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __repr__(self): # reliably restored by inspect
        # no doc
        pass

    def __setattr__(self, name, value): # reliably restored by inspect
        # no doc
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    body = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    header = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    name = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    params = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __annotations__ = {
        'body': str,
        'name': '<value is a self-reference, replaced by this string>',
        'params': type,
    }
    __dataclass_fields__ = {
        'body': None, # (!) real value is "Field(name='body',type=<class 'str'>,default=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,default_factory=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
        'name': None, # (!) real value is "Field(name='name',type=<class 'str'>,default=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,default_factory=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
        'params': None, # (!) real value is "Field(name='params',type=<class 'type'>,default=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,default_factory=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
    }
    __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,order=False,unsafe_hash=False,frozen=True)
    __match_args__ = (
        'name',
        'params',
        'body',
    )
    __mypyc_attrs__ = (
        'name',
        'params',
        'body',
    )


class CellMagicFinder(__ast.NodeVisitor):
    # no doc
    def visit_Expr(self, *args, **kwargs): # real signature unknown
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    cell_magic = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    __weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __dict__ = None # (!) real value is "mappingproxy({'__new__': <built-in method __new__ of type object at 0x0000017750F3EA20>, '__init__': <slot wrapper '__init__' of 'CellMagicFinder' objects>, 'visit_Expr': <method 'visit_Expr' of 'CellMagicFinder' objects>, '__setstate__': <method '__setstate__' of 'CellMagicFinder' objects>, '__getstate__': <method '__getstate__' of 'CellMagicFinder' objects>, '__dict__': <member '__dict__' of 'CellMagicFinder' objects>, '__weakref__': <member '__weakref__' of 'CellMagicFinder' objects>, 'cell_magic': <attribute 'cell_magic' of 'CellMagicFinder' objects>, '__doc__': None, '__module__': 'black.handle_ipynb_magics', '__mypyc_attrs__': ('cell_magic', '__dict__')})"
    __mypyc_attrs__ = (
        'cell_magic',
        '__dict__',
    )


class MagicFinder(__ast.NodeVisitor):
    # no doc
    def visit_Assign(self, *args, **kwargs): # real signature unknown
        pass

    def visit_Expr(self, *args, **kwargs): # real signature unknown
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    magics = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    __weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __dict__ = None # (!) real value is "mappingproxy({'__new__': <built-in method __new__ of type object at 0x0000017750F38330>, '__init__': <slot wrapper '__init__' of 'MagicFinder' objects>, 'visit_Assign': <method 'visit_Assign' of 'MagicFinder' objects>, 'visit_Expr': <method 'visit_Expr' of 'MagicFinder' objects>, '__setstate__': <method '__setstate__' of 'MagicFinder' objects>, '__getstate__': <method '__getstate__' of 'MagicFinder' objects>, '__dict__': <member '__dict__' of 'MagicFinder' objects>, '__weakref__': <member '__weakref__' of 'MagicFinder' objects>, 'magics': <attribute 'magics' of 'MagicFinder' objects>, '__doc__': None, '__module__': 'black.handle_ipynb_magics', '__mypyc_attrs__': ('magics', '__dict__')})"
    __mypyc_attrs__ = (
        'magics',
        '__dict__',
    )


class NothingChanged(UserWarning):
    """ Raised when reformatted code is the same as source. """
    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    __weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """list of weak references to the object (if defined)"""



class OffsetAndMagic(object):
    # no doc
    def __delattr__(self, name): # reliably restored by inspect
        # no doc
        pass

    def __eq__(self, other): # reliably restored by inspect
        # no doc
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __hash__(self): # reliably restored by inspect
        # no doc
        pass

    def __init__(self, col_offset, magic): # reliably restored by inspect
        # no doc
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __repr__(self): # reliably restored by inspect
        # no doc
        pass

    def __setattr__(self, name, value): # reliably restored by inspect
        # no doc
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    col_offset = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    magic = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __annotations__ = {
        'col_offset': int,
        'magic': str,
    }
    __dataclass_fields__ = {
        'col_offset': None, # (!) real value is "Field(name='col_offset',type=<class 'int'>,default=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,default_factory=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
        'magic': None, # (!) real value is "Field(name='magic',type=<class 'str'>,default=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,default_factory=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
    }
    __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,order=False,unsafe_hash=False,frozen=True)
    __match_args__ = (
        'col_offset',
        'magic',
    )
    __mypyc_attrs__ = (
        'col_offset',
        'magic',
    )


class Replacement(object):
    # no doc
    def __delattr__(self, name): # reliably restored by inspect
        # no doc
        pass

    def __eq__(self, other): # reliably restored by inspect
        # no doc
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __hash__(self): # reliably restored by inspect
        # no doc
        pass

    def __init__(self, mask, src): # reliably restored by inspect
        # no doc
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __repr__(self): # reliably restored by inspect
        # no doc
        pass

    def __setattr__(self, name, value): # reliably restored by inspect
        # no doc
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    mask = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    src = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __annotations__ = {
        'mask': str,
        'src': '<value is a self-reference, replaced by this string>',
    }
    __dataclass_fields__ = {
        'mask': None, # (!) real value is "Field(name='mask',type=<class 'str'>,default=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,default_factory=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
        'src': None, # (!) real value is "Field(name='src',type=<class 'str'>,default=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,default_factory=<dataclasses._MISSING_TYPE object at 0x0000017752A34890>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
    }
    __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,order=False,unsafe_hash=False,frozen=True)
    __match_args__ = (
        'mask',
        'src',
    )
    __mypyc_attrs__ = (
        'mask',
        'src',
    )


# variables with complex values

PYTHON_CELL_MAGICS = None # (!) real value is "frozenset({'python', 'prun', 'pypy', 'capture', 'timeit', 'time', 'python3'})"

TOKENS_TO_IGNORE = None # (!) real value is "frozenset({'COMMENT', 'UNIMPORTANT_WS', 'NEWLINE', 'ENDMARKER', 'ESCAPED_NL', 'NL', 'DEDENT'})"

TRANSFORMED_MAGICS = None # (!) real value is "frozenset({'get_ipython().system', 'get_ipython().getoutput', 'get_ipython().run_cell_magic', 'get_ipython().run_line_magic'})"

__loader__ = None # (!) real value is '<_frozen_importlib_external.ExtensionFileLoader object at 0x0000017752C7DFD0>'

__spec__ = None # (!) real value is "ModuleSpec(name='black.handle_ipynb_magics', loader=<_frozen_importlib_external.ExtensionFileLoader object at 0x0000017752C7DFD0>, origin='C:\\\\Users\\\\kosta\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\black\\\\handle_ipynb_magics.cp311-win_amd64.pyd')"

