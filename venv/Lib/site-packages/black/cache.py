# encoding: utf-8
# module black.cache
# from C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\site-packages\black\cache.cp311-win_amd64.pyd
# by generator 1.147
# no doc

# imports
import hashlib as hashlib # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\hashlib.py
import os as os # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\os.py
import pickle as pickle # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\pickle.py
import sys as sys # <module 'sys' (built-in)>
import tempfile as tempfile # C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\tempfile.py
from black.mode import Mode

import pathlib as __pathlib


# Variables with simple values

__version__ = '24.8.0'

# functions

def dataclass(cls=None, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False): # reliably restored by inspect
    """
    Add dunder methods based on the fields defined in the class.
    
        Examines PEP 526 __annotations__ to determine fields.
    
        If init is true, an __init__() method is added to the class. If repr
        is true, a __repr__() method is added. If order is true, rich
        comparison dunder methods are added. If unsafe_hash is true, a
        __hash__() method is added. If frozen is true, fields may not be
        assigned to after instance creation. If match_args is true, the
        __match_args__ tuple is added. If kw_only is true, then by default
        all fields are keyword-only. If slots is true, a new class with a
        __slots__ attribute is returned.
    """
    pass

def Dict(*args, **kwargs): # real signature unknown
    """ A generic version of dict. """
    pass

def err(message=None, nl=True, **styles): # reliably restored by inspect
    # no doc
    pass

def field(*, default='<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>', default_factory='<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>', init=True, repr=True, hash=None, compare=True, metadata=None, kw_only='<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>'): # reliably restored by inspect
    """
    Return an object to identify dataclass fields.
    
        default is the default value of the field.  default_factory is a
        0-argument function called to initialize a field's value.  If init
        is true, the field will be a parameter to the class's __init__()
        function.  If repr is true, the field will be included in the
        object's repr().  If hash is true, the field will be included in the
        object's hash().  If compare is true, the field will be used in
        comparison functions.  metadata, if specified, must be a mapping
        which is stored but not otherwise examined by dataclass.  If kw_only
        is true, the field will become a keyword-only parameter to
        __init__().
    
        It is an error to specify both default and default_factory.
    """
    pass

def get_cache_dir(*args, **kwargs): # real signature unknown
    pass

def get_cache_file(*args, **kwargs): # real signature unknown
    pass

def Iterable(*args, **kwargs): # real signature unknown
    """ A generic version of collections.abc.Iterable. """
    pass

def NamedTuple(typename, fields=None, **kwargs): # reliably restored by inspect
    """
    Typed version of namedtuple.
    
        Usage::
    
            class Employee(NamedTuple):
                name: str
                id: int
    
        This is equivalent to::
    
            Employee = collections.namedtuple('Employee', ['name', 'id'])
    
        The resulting class has an extra __annotations__ attribute, giving a
        dict that maps field names to types.  (The field names are also in
        the _fields attribute, which is part of the namedtuple API.)
        An alternative equivalent functional syntax is also accepted::
    
            Employee = NamedTuple('Employee', [('name', str), ('id', int)])
    """
    pass

def Self(*args, **kwargs): # real signature unknown
    """
    Used to spell the type of "self" in classes.
    
        Example::
    
            from typing import Self
    
            class Foo:
                def return_self(self) -> Self:
                    ...
                    return self
    
        This is especially useful for:
            - classmethods that are used as alternative constructors
            - annotating an `__enter__` method which returns self
    """
    pass

def Set(*args, **kwargs): # real signature unknown
    """ A generic version of set. """
    pass

def Tuple(*args, **kwargs): # real signature unknown
    """
    Deprecated alias to builtins.tuple.
    
        Tuple[X, Y] is the cross-product type of X and Y.
    
        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.
    
        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
    """
    pass

def user_cache_dir(appname=None, appauthor=None, version=None, opinion=True, ensure_exists=False): # reliably restored by inspect
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
        :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
        :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
        :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.
        :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
        :returns: cache directory tied to the user
    """
    pass

# classes

class Cache(object):
    # no doc
    def filtered_cached(self, *args, **kwargs): # real signature unknown
        pass

    def get_file_data(self, *args, **kwargs): # real signature unknown
        pass

    def hash_digest(self, *args, **kwargs): # real signature unknown
        pass

    def is_changed(self, *args, **kwargs): # real signature unknown
        pass

    @classmethod
    def read(cls, *args, **kwargs): # real signature unknown
        pass

    def write(self, *args, **kwargs): # real signature unknown
        pass

    def __eq__(self, other): # reliably restored by inspect
        # no doc
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __init__(self, mode, cache_file, file_data='<factory>'): # reliably restored by inspect
        # no doc
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __repr__(self): # reliably restored by inspect
        # no doc
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    cache_file = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    file_data = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    mode = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __annotations__ = {
        'cache_file': None, # (!) forward: Path, real value is "<class 'pathlib.Path'>"
        'file_data': dict,
        'mode': None, # (!) forward: Mode, real value is "<class 'black.mode.Mode'>"
    }
    __dataclass_fields__ = {
        'cache_file': None, # (!) real value is "Field(name='cache_file',type=<class 'pathlib.Path'>,default=<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>,default_factory=<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
        'file_data': None, # (!) real value is "Field(name='file_data',type=<class 'dict'>,default=<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>,default_factory=<class 'dict'>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
        'mode': None, # (!) real value is "Field(name='mode',type=<class 'black.mode.Mode'>,default=<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>,default_factory=<dataclasses._MISSING_TYPE object at 0x00000235CD4447D0>,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=False,_field_type=_FIELD)"
    }
    __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,order=False,unsafe_hash=False,frozen=False)
    __hash__ = None
    __match_args__ = (
        'mode',
        'cache_file',
        'file_data',
    )
    __mypyc_attrs__ = (
        'mode',
        'cache_file',
        'file_data',
    )


class FileData(tuple):
    """ mypyc filler docstring """
    def _asdict(self): # reliably restored by inspect
        """ Return a new dict which maps field names to their values. """
        pass

    @classmethod
    def _make(cls, *args, **kwargs): # real signature unknown
        """ Make a new FileData object from a sequence or iterable """
        pass

    def _replace(self, **kwds): # reliably restored by inspect
        """ Return a new FileData object replacing specified fields with new values """
        pass

    def __getnewargs__(self): # reliably restored by inspect
        """ Return self as a plain tuple.  Used by copy and pickle. """
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    @staticmethod # known case of __new__
    def __new__(_cls, st_mtime, st_size, hash): # reliably restored by inspect
        """ Create new instance of FileData(st_mtime, st_size, hash) """
        pass

    def __repr__(self): # reliably restored by inspect
        """ Return a nicely formatted representation string """
        pass

    hash = _tuplegetter(2, 'Alias for field number 2')
    st_mtime = _tuplegetter(0, 'Alias for field number 0')
    st_size = _tuplegetter(1, 'Alias for field number 1')
    _fields = (
        'st_mtime',
        'st_size',
        'hash',
    )
    _field_defaults = {}
    __annotations__ = {
        'hash': str,
        'st_mtime': float,
        'st_size': int,
    }
    __match_args__ = (
        'st_mtime',
        'st_size',
        'hash',
    )
    __slots__ = ()


class Path(__pathlib.PurePath):
    """
    PurePath subclass that can make system calls.
    
        Path represents a filesystem path but unlike PurePath, also offers
        methods to do system calls on path objects. Depending on your system,
        instantiating a Path will return either a PosixPath or a WindowsPath
        object. You can also instantiate a PosixPath or WindowsPath directly,
        but cannot instantiate a WindowsPath on a POSIX system or vice versa.
    """
    def absolute(self): # reliably restored by inspect
        """
        Return an absolute version of this path by prepending the current
                working directory. No normalization or symlink resolution is performed.
        
                Use resolve() to get the canonical path to a file.
        """
        pass

    def chmod(self, mode, *, follow_symlinks=True): # reliably restored by inspect
        """ Change the permissions of the path, like os.chmod(). """
        pass

    @classmethod
    def cwd(cls): # real signature unknown; restored from __doc__
        """
        Return a new path pointing to the current working directory
                (as returned by os.getcwd()).
        """
        pass

    def exists(self): # reliably restored by inspect
        """ Whether this path exists. """
        pass

    def expanduser(self): # reliably restored by inspect
        """
        Return a new path with expanded ~ and ~user constructs
                (as returned by os.path.expanduser)
        """
        pass

    def glob(self, pattern): # reliably restored by inspect
        """
        Iterate over this subtree and yield all existing files (of any
                kind, including directories) matching the given relative pattern.
        """
        pass

    def group(self): # reliably restored by inspect
        """ Return the group name of the file gid. """
        pass

    def hardlink_to(self, target): # reliably restored by inspect
        """
        Make this path a hard link pointing to the same file as *target*.
        
                Note the order of arguments (self, target) is the reverse of os.link's.
        """
        pass

    @classmethod
    def home(cls, *args, **kwargs): # real signature unknown
        """
        Return a new path pointing to the user's home directory (as
                returned by os.path.expanduser('~')).
        """
        pass

    def is_block_device(self): # reliably restored by inspect
        """ Whether this path is a block device. """
        pass

    def is_char_device(self): # reliably restored by inspect
        """ Whether this path is a character device. """
        pass

    def is_dir(self): # reliably restored by inspect
        """ Whether this path is a directory. """
        pass

    def is_fifo(self): # reliably restored by inspect
        """ Whether this path is a FIFO. """
        pass

    def is_file(self): # reliably restored by inspect
        """
        Whether this path is a regular file (also True for symlinks pointing
                to regular files).
        """
        pass

    def is_mount(self): # reliably restored by inspect
        """ Check if this path is a POSIX mount point """
        pass

    def is_socket(self): # reliably restored by inspect
        """ Whether this path is a socket. """
        pass

    def is_symlink(self): # reliably restored by inspect
        """ Whether this path is a symbolic link. """
        pass

    def iterdir(self): # reliably restored by inspect
        """
        Iterate over the files in this directory.  Does not yield any
                result for the special paths '.' and '..'.
        """
        pass

    def lchmod(self, mode): # reliably restored by inspect
        """
        Like chmod(), except if the path points to a symlink, the symlink's
                permissions are changed, rather than its target's.
        """
        pass

    def link_to(self, target): # reliably restored by inspect
        """
        Make the target path a hard link pointing to this path.
        
                Note this function does not make this path a hard link to *target*,
                despite the implication of the function and argument names. The order
                of arguments (target, link) is the reverse of Path.symlink_to, but
                matches that of os.link.
        
                Deprecated since Python 3.10 and scheduled for removal in Python 3.12.
                Use `hardlink_to()` instead.
        """
        pass

    def lstat(self): # reliably restored by inspect
        """
        Like stat(), except if the path points to a symlink, the symlink's
                status information is returned, rather than its target's.
        """
        pass

    def mkdir(self, mode=511, parents=False, exist_ok=False): # reliably restored by inspect
        """ Create a new directory at this given path. """
        pass

    def open(self, mode=None, buffering=-1, encoding=None, errors=None, newline=None): # reliably restored by inspect
        """
        Open the file pointed by this path and return a file object, as
                the built-in open() function does.
        """
        pass

    def owner(self): # reliably restored by inspect
        """ Return the login name of the file owner. """
        pass

    def readlink(self): # reliably restored by inspect
        """ Return the path to which the symbolic link points. """
        pass

    def read_bytes(self): # reliably restored by inspect
        """ Open the file in bytes mode, read it, and close the file. """
        pass

    def read_text(self, encoding=None, errors=None): # reliably restored by inspect
        """ Open the file in text mode, read it, and close the file. """
        pass

    def rename(self, target): # reliably restored by inspect
        """
        Rename this path to the target path.
        
                The target path may be absolute or relative. Relative paths are
                interpreted relative to the current working directory, *not* the
                directory of the Path object.
        
                Returns the new Path instance pointing to the target path.
        """
        pass

    def replace(self, target): # reliably restored by inspect
        """
        Rename this path to the target path, overwriting if that path exists.
        
                The target path may be absolute or relative. Relative paths are
                interpreted relative to the current working directory, *not* the
                directory of the Path object.
        
                Returns the new Path instance pointing to the target path.
        """
        pass

    def resolve(self, strict=False): # reliably restored by inspect
        """
        Make the path absolute, resolving all symlinks on the way and also
                normalizing it.
        """
        pass

    def rglob(self, pattern): # reliably restored by inspect
        """
        Recursively yield all existing files (of any kind, including
                directories) matching the given relative pattern, anywhere in
                this subtree.
        """
        pass

    def rmdir(self): # reliably restored by inspect
        """ Remove this directory.  The directory must be empty. """
        pass

    def samefile(self, other_path): # reliably restored by inspect
        """
        Return whether other_path is the same or not as this file
                (as returned by os.path.samefile()).
        """
        pass

    def stat(self, *, follow_symlinks=True): # reliably restored by inspect
        """
        Return the result of the stat() system call on this path, like
                os.stat() does.
        """
        pass

    def symlink_to(self, target, target_is_directory=False): # reliably restored by inspect
        """
        Make this path a symlink pointing to the target path.
                Note the order of arguments (link, target) is the reverse of os.symlink.
        """
        pass

    def touch(self, mode=438, exist_ok=True): # reliably restored by inspect
        """ Create this file with the given access mode, if it doesn't exist. """
        pass

    def unlink(self, missing_ok=False): # reliably restored by inspect
        """
        Remove this file or link.
                If the path is a directory, use rmdir() instead.
        """
        pass

    def write_bytes(self, data): # reliably restored by inspect
        """ Open the file in bytes mode, write to it, and close the file. """
        pass

    def write_text(self, data, encoding=None, errors=None, newline=None): # reliably restored by inspect
        """ Open the file in text mode, write to it, and close the file. """
        pass

    def _make_child_relpath(self, part): # reliably restored by inspect
        # no doc
        pass

    def _scandir(self): # reliably restored by inspect
        # no doc
        pass

    def __enter__(self): # reliably restored by inspect
        # no doc
        pass

    def __exit__(self, t, v, tb): # reliably restored by inspect
        # no doc
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    @staticmethod # known case of __new__
    def __new__(cls, *args, **kwargs): # reliably restored by inspect
        # no doc
        pass

    __slots__ = ()


# variables with complex values

CACHE_DIR = None # (!) real value is "WindowsPath('C:/Users/kosta/AppData/Local/black/black/Cache/24.8.0')"

__loader__ = None # (!) real value is '<_frozen_importlib_external.ExtensionFileLoader object at 0x00000235CD623410>'

__spec__ = None # (!) real value is "ModuleSpec(name='black.cache', loader=<_frozen_importlib_external.ExtensionFileLoader object at 0x00000235CD623410>, origin='C:\\\\Users\\\\kosta\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\black\\\\cache.cp311-win_amd64.pyd')"

