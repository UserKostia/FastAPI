# encoding: utf-8
# module black.rusty
# from C:\Users\kosta\AppData\Local\Programs\Python\Python311\Lib\site-packages\black\rusty.cp311-win_amd64.pyd
# by generator 1.147
# no doc

# imports
import typing as __typing


# functions

def Result(*args, **kwargs): # real signature unknown
    pass

def Union(*args, **kwargs): # real signature unknown
    """
    Union type; Union[X, Y] means either X or Y.
    
        On Python 3.10 and higher, the | operator
        can also be used to denote unions;
        X | Y means the same thing to the type checker as Union[X, Y].
    
        To define a union, use e.g. Union[int, str]. Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::
    
            assert Union[Union[int, str], float] == Union[int, str, float]
    
        - Unions of a single argument vanish, e.g.::
    
            assert Union[int] == int  # The constructor actually returns int
    
        - Redundant arguments are skipped, e.g.::
    
            assert Union[int, str, int] == Union[int, str]
    
        - When comparing unions, the argument order is ignored, e.g.::
    
            assert Union[int, str] == Union[str, int]
    
        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].
    """
    pass

# classes

class Generic(object):
    """
    Abstract base class for generic types.
    
        A generic type is typically declared by inheriting from
        this class parameterized with one or more type variables.
        For example, a generic mapping type might be defined as::
    
          class Mapping(Generic[KT, VT]):
              def __getitem__(self, key: KT) -> VT:
                  ...
              # Etc.
    
        This class can then be used as follows::
    
          def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
              try:
                  return mapping[key]
              except KeyError:
                  return default
    """
    @classmethod
    def __class_getitem__(cls, *args, **kwargs): # real signature unknown
        """
        Parameterizes a generic class.
        
                At least, parameterizing a generic class is the *main* thing this method
                does. For example, for some generic class `Foo`, this is called when we
                do `Foo[int]` - there, with `cls=Foo` and `params=int`.
        
                However, note that this method is also called when defining generic
                classes in the first place with `class Foo(Generic[T]): ...`.
        """
        pass

    @classmethod
    def __init_subclass__(cls, *args, **kwargs): # real signature unknown
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    _is_protocol = False
    __slots__ = ()


class Err(__typing.Generic):
    # no doc
    def err(self, *args, **kwargs): # real signature unknown
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    _e = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    __weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __dict__ = None # (!) real value is "mappingproxy({'__orig_bases__': (typing.Generic[~E],), '__new__': <built-in method __new__ of type object at 0x0000028F5D61C890>, '__init__': <slot wrapper '__init__' of 'Err' objects>, 'err': <method 'err' of 'Err' objects>, '__setstate__': <method '__setstate__' of 'Err' objects>, '__getstate__': <method '__getstate__' of 'Err' objects>, '__dict__': <member '__dict__' of 'Err' objects>, '__weakref__': <member '__weakref__' of 'Err' objects>, '_e': <attribute '_e' of 'Err' objects>, '__doc__': None, '__module__': 'black.rusty', '__parameters__': (~E,), '__mypyc_attrs__': ('_e', '__dict__')})"
    __mypyc_attrs__ = (
        '_e',
        '__dict__',
    )
    __orig_bases__ = (
        typing.Generic[~E],
    )
    __parameters__ = (
        None, # (!) forward: E, real value is '~E'
    )


class Ok(__typing.Generic):
    # no doc
    def ok(self, *args, **kwargs): # real signature unknown
        pass

    def __getstate__(self, *args, **kwargs): # real signature unknown
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __setstate__(self, *args, **kwargs): # real signature unknown
        pass

    _value = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default

    __weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default


    __dict__ = None # (!) real value is "mappingproxy({'__orig_bases__': (typing.Generic[~T],), '__new__': <built-in method __new__ of type object at 0x0000028F5D61C4C0>, '__init__': <slot wrapper '__init__' of 'Ok' objects>, 'ok': <method 'ok' of 'Ok' objects>, '__setstate__': <method '__setstate__' of 'Ok' objects>, '__getstate__': <method '__getstate__' of 'Ok' objects>, '__dict__': <member '__dict__' of 'Ok' objects>, '__weakref__': <member '__weakref__' of 'Ok' objects>, '_value': <attribute '_value' of 'Ok' objects>, '__doc__': None, '__module__': 'black.rusty', '__parameters__': (~T,), '__mypyc_attrs__': ('_value', '__dict__')})"
    __mypyc_attrs__ = (
        '_value',
        '__dict__',
    )
    __orig_bases__ = (
        typing.Generic[~T],
    )
    __parameters__ = (
        None, # (!) forward: T, real value is '~T'
    )


class TypeVar(__typing._Final, __typing._Immutable, __typing._BoundVarianceMixin, __typing._PickleUsingNameMixin):
    """
    Type variable.
    
        Usage::
    
          T = TypeVar('T')  # Can be anything
          A = TypeVar('A', str, bytes)  # Must be str or bytes
    
        Type variables exist primarily for the benefit of static type
        checkers.  They serve as the parameters for generic types as well
        as for generic function definitions.  See class Generic for more
        information on generic types.  Generic functions work as follows:
    
          def repeat(x: T, n: int) -> List[T]:
              '''Return a list containing n references to x.'''
              return [x]*n
    
          def longest(x: A, y: A) -> A:
              '''Return the longest of two strings.'''
              return x if len(x) >= len(y) else y
    
        The latter example's signature is essentially the overloading
        of (str, str) -> str and (bytes, bytes) -> bytes.  Also note
        that if the arguments are instances of some subclass of str,
        the return type is still plain str.
    
        At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.
    
        Type variables defined with covariant=True or contravariant=True
        can be used to declare covariant or contravariant generic types.
        See PEP 484 for more details. By default generic types are invariant
        in all type variables.
    
        Type variables can be introspected. e.g.:
    
          T.__name__ == 'T'
          T.__constraints__ == ()
          T.__covariant__ == False
          T.__contravariant__ = False
          A.__constraints__ == (str, bytes)
    
        Note that only type variables defined in global scope can be pickled.
    """
    def __init__(self, name, *constraints, bound=None, covariant=False, contravariant=False): # reliably restored by inspect
        # no doc
        pass

    def __typing_subst__(self, arg): # reliably restored by inspect
        # no doc
        pass

    __dict__ = None # (!) real value is 'mappingproxy({\'__module__\': \'typing\', \'__doc__\': "Type variable.\\n\\n    Usage::\\n\\n      T = TypeVar(\'T\')  # Can be anything\\n      A = TypeVar(\'A\', str, bytes)  # Must be str or bytes\\n\\n    Type variables exist primarily for the benefit of static type\\n    checkers.  They serve as the parameters for generic types as well\\n    as for generic function definitions.  See class Generic for more\\n    information on generic types.  Generic functions work as follows:\\n\\n      def repeat(x: T, n: int) -> List[T]:\\n          \'\'\'Return a list containing n references to x.\'\'\'\\n          return [x]*n\\n\\n      def longest(x: A, y: A) -> A:\\n          \'\'\'Return the longest of two strings.\'\'\'\\n          return x if len(x) >= len(y) else y\\n\\n    The latter example\'s signature is essentially the overloading\\n    of (str, str) -> str and (bytes, bytes) -> bytes.  Also note\\n    that if the arguments are instances of some subclass of str,\\n    the return type is still plain str.\\n\\n    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\\n\\n    Type variables defined with covariant=True or contravariant=True\\n    can be used to declare covariant or contravariant generic types.\\n    See PEP 484 for more details. By default generic types are invariant\\n    in all type variables.\\n\\n    Type variables can be introspected. e.g.:\\n\\n      T.__name__ == \'T\'\\n      T.__constraints__ == ()\\n      T.__covariant__ == False\\n      T.__contravariant__ = False\\n      A.__constraints__ == (str, bytes)\\n\\n    Note that only type variables defined in global scope can be pickled.\\n    ", \'__init__\': <function TypeVar.__init__ at 0x0000028F5D6B82C0>, \'__typing_subst__\': <function TypeVar.__typing_subst__ at 0x0000028F5D6B8360>, \'__dict__\': <attribute \'__dict__\' of \'TypeVar\' objects>})'


# variables with complex values

E = None # (!) real value is '~E'

T = None # (!) real value is '~T'

__loader__ = None # (!) real value is '<_frozen_importlib_external.ExtensionFileLoader object at 0x0000028F5FC1B810>'

__spec__ = None # (!) real value is "ModuleSpec(name='black.rusty', loader=<_frozen_importlib_external.ExtensionFileLoader object at 0x0000028F5FC1B810>, origin='C:\\\\Users\\\\kosta\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\black\\\\rusty.cp311-win_amd64.pyd')"

